apiVersion: v1
kind: ServiceAccount
metadata:
  name: velero-healthcheck
  namespace: velero
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: velero-healthcheck
  namespace: velero
rules:
  - apiGroups: ["velero.io"]
    resources: ["backups"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: velero-healthcheck
  namespace: velero
subjects:
  - kind: ServiceAccount
    name: velero-healthcheck
    namespace: velero
roleRef:
  kind: Role
  name: velero-healthcheck
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: velero-healthcheck-script
  namespace: velero
data:
  velero-healthcheck.py: |
    import json
    import sys
    import subprocess
    import datetime
    import urllib.request
    import os
    import argparse

    # Configuration
    VELERO_NAMESPACE = "velero"
    MAX_AGE_SECONDS = 3600 * 25  # 25 hours (daily backups + 1 hour buffer)

    def get_latest_backup(schedule_name):
        # Get backups for the schedule, sorted by creation timestamp descending
        cmd = [
            "kubectl", "get", "backups", "-n", VELERO_NAMESPACE,
            "-l", f"velero.io/schedule-name={schedule_name}",
            "--sort-by=.metadata.creationTimestamp",
            "-o", "json"
        ]
        try:
            result = subprocess.check_output(cmd).decode("utf-8")
            data = json.loads(result)
            items = data.get("items", [])
            if not items:
                return None
            return items[-1] # Last item is the newest due to sort
        except subprocess.CalledProcessError as e:
            print(f"Error getting backups: {e}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON: {e}")
            sys.exit(1)

    def check_backup_status(backup):
        if not backup:
            print("No backups found for schedule")
            return False

        metadata = backup.get("metadata", {})
        name = metadata.get("name")
        creation_timestamp_str = metadata.get("creationTimestamp")
        
        status = backup.get("status", {})
        phase = status.get("phase")
        
        print(f"Checking backup: {name}")
        print(f"Phase: {phase}")
        print(f"Created: {creation_timestamp_str}")

        if phase != "Completed":
            print(f"Backup phase is '{phase}', not 'Completed'")
            return False

        # Parse timestamp (RFC3339)
        if creation_timestamp_str.endswith('Z'):
            creation_timestamp_str = creation_timestamp_str[:-1] + '+00:00'
        
        try:
            creation_time = datetime.datetime.fromisoformat(creation_timestamp_str)
        except ValueError as e:
            print(f"Error parsing timestamp {creation_timestamp_str}: {e}")
            return False

        now = datetime.datetime.now(datetime.timezone.utc)
        age = (now - creation_time).total_seconds()
        
        print(f"Backup age: {age} seconds")
        
        if age > MAX_AGE_SECONDS:
            print(f"Backup is too old (> {MAX_AGE_SECONDS} seconds)")
            return False
            
        return True

    def ping_healthchecks(url):
        if not url:
            print("Healthcheck URL not provided")
            return

        try:
            urllib.request.urlopen(url, timeout=10)
            print("Pinged Healthchecks.io successfully")
        except Exception as e:
            print(f"Error pinging Healthchecks.io: {e}")

    def main():
        parser = argparse.ArgumentParser(description='Check Velero backup status')
        parser.add_argument('--schedule', required=True, help='Velero schedule name')
        parser.add_argument('--hc-url', required=True, help='Healthchecks.io ping URL')
        args = parser.parse_args()

        backup = get_latest_backup(args.schedule)
        
        if check_backup_status(backup):
            ping_healthchecks(args.hc_url)
        else:
            print("Backup check failed")
            sys.exit(1)

  namespace: velero
spec:
  schedule: "0 * * * *" # Every hour
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: velero-healthcheck
          containers:
            - name: velero-healthcheck
              image: python:3-slim
              command: ["/bin/bash", "-c"]
              args:
                - |
                  apt-get update && apt-get install -y curl && \
                  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" && \
                  chmod +x kubectl && \
                  mv kubectl /usr/local/bin/ && \
                  python /scripts/velero-healthcheck.py --schedule immich --hc-url "http://healthchecks.healthchecks.svc.cluster.local/ping/95fecc61-7345-4b37-902d-3f8d28072aa8"
              volumeMounts:
                - name: script
                  mountPath: /scripts
          volumes:
            - name: script
              configMap:
                name: velero-healthcheck-script
          restartPolicy: OnFailure
