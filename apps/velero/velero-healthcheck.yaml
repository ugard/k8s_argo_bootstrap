apiVersion: v1
kind: ServiceAccount
metadata:
  name: velero-healthcheck
  namespace: velero
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: velero-healthcheck
  namespace: velero
rules:
  - apiGroups: ["velero.io"]
    resources: ["backups"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: velero-healthcheck
  namespace: velero
subjects:
  - kind: ServiceAccount
    name: velero-healthcheck
    namespace: velero
roleRef:
  kind: Role
  name: velero-healthcheck
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: velero-healthcheck-script
  namespace: velero
data:
  velero-healthcheck.py: |
    import json
    import sys
    import subprocess
    import datetime
    import urllib.request
    import os
    import argparse

    # Configuration
    VELERO_NAMESPACE = "velero"
    MAX_AGE_SECONDS = 3600 * 25  # 25 hours (daily backups + 1 hour buffer)

    def get_latest_backup(schedule_name):
        # Get backups for the schedule, sorted by creation timestamp descending
        cmd = [
            "kubectl", "get", "backups", "-n", VELERO_NAMESPACE,
            "-l", f"velero.io/schedule-name={schedule_name}",
            "--sort-by=.metadata.creationTimestamp",
            "-o", "json"
        ]
        try:
            result = subprocess.check_output(cmd).decode("utf-8")
            data = json.loads(result)
            items = data.get("items", [])
            if not items:
                return None
            return items[-1] # Last item is the newest due to sort
        except subprocess.CalledProcessError as e:
            print(f"Error getting backups for {schedule_name}: {e}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON for {schedule_name}: {e}")
            sys.exit(1)

    def parse_timestamp(timestamp_str):
        if not timestamp_str:
            return None
        if timestamp_str.endswith('Z'):
            timestamp_str = timestamp_str[:-1] + '+00:00'
        try:
            return datetime.datetime.fromisoformat(timestamp_str)
        except ValueError as e:
            print(f"Error parsing timestamp {timestamp_str}: {e}")
            return None

    def check_backup_status(backup, schedule_name):
        if not backup:
            print(f"No backups found for schedule {schedule_name}")
            return False, 0, 0

        metadata = backup.get("metadata", {})
        name = metadata.get("name")
        creation_timestamp_str = metadata.get("creationTimestamp")
        
        status = backup.get("status", {})
        phase = status.get("phase")
        start_timestamp_str = status.get("startTimestamp")
        completion_timestamp_str = status.get("completionTimestamp")
        
        print(f"Checking backup: {name} (Schedule: {schedule_name})")
        print(f"Phase: {phase}")
        print(f"Created: {creation_timestamp_str}")

        if phase != "Completed":
            print(f"Backup phase is '{phase}', not 'Completed'")
            return False, 0, 0

        creation_time = parse_timestamp(creation_timestamp_str)
        if not creation_time:
            return False, 0, 0

        now = datetime.datetime.now(datetime.timezone.utc)
        age = (now - creation_time).total_seconds()
        
        print(f"Backup age: {age} seconds")
        
        if age > MAX_AGE_SECONDS:
            print(f"Backup is too old (> {MAX_AGE_SECONDS} seconds)")
            return False, 0, 0
            
        # Calculate duration
        duration = 0
        start_time = parse_timestamp(start_timestamp_str)
        completion_time = parse_timestamp(completion_timestamp_str)
        
        if start_time and completion_time:
            duration = (completion_time - start_time).total_seconds()
            print(f"Backup duration: {duration} seconds")
        else:
            print("Could not calculate duration (missing start or completion time)")

        # Get size
        size = 0
        progress = status.get("progress", {})
        if "totalBytes" in progress:
            size = progress["totalBytes"]
            print(f"Backup size: {size} bytes")
        else:
            print("Backup size not found in status.progress.totalBytes")

        return True, duration, size

    def ping_healthchecks(url, duration=None, size=None):
        if not url:
            print("Healthcheck URL not provided")
            return

        try:
            data = None
            if duration is not None:
                # Send duration and size as body (will be logged by HC)
                # If we send just a number, it's duration. If we send text, it's a log.
                # We prioritize showing both info.
                log_content = f"Duration: {duration} seconds\n"
                if size is not None:
                    log_content += f"Size: {size} bytes\n"
                
                data = log_content.encode('utf-8')
                
            req = urllib.request.Request(url, data=data)
            urllib.request.urlopen(req, timeout=10)
            print(f"Pinged Healthchecks.io successfully (Duration: {duration}, Size: {size})")
        except Exception as e:
            print(f"Error pinging Healthchecks.io: {e}")

    def main():
        parser = argparse.ArgumentParser(description='Check Velero backup status')
        parser.add_argument('--schedule', action='append', required=True, help='Velero schedule name (can be specified multiple times)')
        parser.add_argument('--hc-url', required=True, help='Healthchecks.io ping URL')
        args = parser.parse_args()

        all_success = True
        total_duration = 0
        total_size = 0

        for schedule in args.schedule:
            backup = get_latest_backup(schedule)
            success, duration, size = check_backup_status(backup, schedule)
            if not success:
                all_success = False
            total_duration += duration
            total_size += size

        if all_success:
            ping_healthchecks(args.hc_url, total_duration, total_size)
        else:
            print("One or more backup checks failed")
            sys.exit(1)

    if __name__ == "__main__":
        main()
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: velero-healthcheck
  namespace: velero
spec:
  schedule: "0 * * * *" # Every hour
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: velero-healthcheck
          containers:
            - name: velero-healthcheck
              image: python:3-slim
              command: ["/bin/bash", "-c"]
              args:
                - |
                  apt-get update && apt-get install -y curl && \
                  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" && \
                  chmod +x kubectl && \
                  mv kubectl /usr/local/bin/ && \
                  python /scripts/velero-healthcheck.py --schedule immich --hc-url "http://healthchecks.healthchecks.svc.cluster.local/ping/95fecc61-7345-4b37-902d-3f8d28072aa8" && \
                  python /scripts/velero-healthcheck.py --schedule garage-meta-ceph --schedule garage-data-zfs --hc-url "http://healthchecks.healthchecks.svc.cluster.local/ping/b2a8aa84-740c-42a3-8d2c-dc4879f8ebc3" && \
                  python /scripts/velero-healthcheck.py --schedule postgres-backup --hc-url "http://healthchecks.healthchecks.svc.cluster.local/ping/0fab098b-990b-4de5-b317-5e66a62054c2" && \
                  python /scripts/velero-healthcheck.py --schedule hoarder-backup --hc-url "http://healthchecks.healthchecks.svc.cluster.local/ping/ad8a3d86-4794-4c74-8a71-7f8162f92f0d"
              volumeMounts:
                - name: script
                  mountPath: /scripts
          volumes:
            - name: script
              configMap:
                name: velero-healthcheck-script
          restartPolicy: OnFailure
