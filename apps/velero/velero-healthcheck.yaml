apiVersion: v1
kind: ServiceAccount
metadata:
  name: velero-healthcheck
  namespace: velero
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: velero-healthcheck
  namespace: velero
rules:
  - apiGroups: ["velero.io"]
    resources: ["backups"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: velero-healthcheck
  namespace: velero
subjects:
  - kind: ServiceAccount
    name: velero-healthcheck
    namespace: velero
roleRef:
  kind: Role
  name: velero-healthcheck
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: velero-healthcheck-script
  namespace: velero
data:
  velero-healthcheck.py: |
    import json
    import sys
    import subprocess
    import datetime
    import urllib.request
    import os
    import argparse

    # Configuration
    VELERO_NAMESPACE = "velero"
    MAX_AGE_SECONDS = 3600 * 25  # 25 hours (daily backups + 1 hour buffer)

    def get_latest_backup(schedule_name):
        # Get backups for the schedule, sorted by creation timestamp descending
        cmd = [
            "kubectl", "get", "backups", "-n", VELERO_NAMESPACE,
            "-l", f"velero.io/schedule-name={schedule_name}",
            "--sort-by=.metadata.creationTimestamp",
            "-o", "json"
        ]
        try:
            result = subprocess.check_output(cmd).decode("utf-8")
            data = json.loads(result)
            items = data.get("items", [])
            if not items:
                return None
            return items[-1] # Last item is the newest due to sort
        except subprocess.CalledProcessError as e:
            print(f"Error getting backups for {schedule_name}: {e}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON for {schedule_name}: {e}")
            sys.exit(1)

    def parse_timestamp(timestamp_str):
        if not timestamp_str:
            return None
        if timestamp_str.endswith('Z'):
            timestamp_str = timestamp_str[:-1] + '+00:00'
        try:
            return datetime.datetime.fromisoformat(timestamp_str)
        except ValueError as e:
        try:
            data = None
            if duration is not None:
                # Send duration and size as body (will be logged by HC)
                # If we send just a number, it's duration. If we send text, it's a log.
                # We prioritize showing both info.
                log_content = f"Duration: {duration} seconds\n"
                if size is not None:
                    log_content += f"Size: {size} bytes\n"
                
                data = log_content.encode('utf-8')
                
            req = urllib.request.Request(url, data=data)
            urllib.request.urlopen(req, timeout=10)
            print(f"Pinged Healthchecks.io successfully (Duration: {duration}, Size: {size})")
        except Exception as e:
            print(f"Error pinging Healthchecks.io: {e}")

    def main():
        parser = argparse.ArgumentParser(description='Check Velero backup status')
        parser.add_argument('--schedule', action='append', required=True, help='Velero schedule name (can be specified multiple times)')
        parser.add_argument('--hc-url', required=True, help='Healthchecks.io ping URL')
        args = parser.parse_args()

        all_success = True
        total_duration = 0
        total_size = 0

        for schedule in args.schedule:
            backup = get_latest_backup(schedule)
            success, duration, size = check_backup_status(backup, schedule)
            if not success:
                all_success = False
            total_duration += duration
            total_size += size

        if all_success:
            ping_healthchecks(args.hc_url, total_duration, total_size)
        else:
            print("One or more backup checks failed")
            sys.exit(1)

    if __name__ == "__main__":
        main()
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: velero-healthcheck
  namespace: velero
spec:
  schedule: "0 * * * *" # Every hour
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: velero-healthcheck
          containers:
            - name: velero-healthcheck
              image: python:3-slim
              command: ["/bin/bash", "-c"]
              args:
                - |
                  apt-get update && apt-get install -y curl && \
                  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" && \
                  chmod +x kubectl && \
                  mv kubectl /usr/local/bin/ && \
                  python /scripts/velero-healthcheck.py --schedule immich --hc-url "http://healthchecks.healthchecks.svc.cluster.local/ping/95fecc61-7345-4b37-902d-3f8d28072aa8" && \
                  python /scripts/velero-healthcheck.py --schedule garage-meta-ceph --schedule garage-data-zfs --hc-url "http://healthchecks.healthchecks.svc.cluster.local/ping/b2a8aa84-740c-42a3-8d2c-dc4879f8ebc3" && \
                  python /scripts/velero-healthcheck.py --schedule postgres-backup --hc-url "http://healthchecks.healthchecks.svc.cluster.local/ping/0fab098b-990b-4de5-b317-5e66a62054c2" && \
                  python /scripts/velero-healthcheck.py --schedule hoarder-backup --hc-url "http://healthchecks.healthchecks.svc.cluster.local/ping/ad8a3d86-4794-4c74-8a71-7f8162f92f0d"
              volumeMounts:
                - name: script
                  mountPath: /scripts
          volumes:
            - name: script
              configMap:
                name: velero-healthcheck-script
          restartPolicy: OnFailure
